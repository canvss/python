python基础语法
ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符

要注意区分’ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。

占位符  print('Hi,%s' %('ENDLESS'))
	%d	整数
	%f	浮点
	%s	字符串
	%x	16进制整数

format()
f-string()
List和tuple是Python内置的有序集合，一个可变，一个不可变
break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。

python函数
	定义函数时，需要确定函数名和参数个数
	如果有必要，可以先对参数的数据类型做检查；
	函数体内部可以用return随时返回函数结果；
	函数执行完毕也没有return语句时，自动return None。
	函数可以同时返回多个值，但其实就是一个tuple。
	*args是可变参数，args接收的是一个tuple；
	**kw是关键字参数，kw接收的是一个dict。
	设置默认参数时，有几点要注意：
        一是必选参数在前，默认参数在后，否则Python的解释器会报错
        默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。
        有多个默认参数时，调用的时候，既可以按顺序提供默认参数
        不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上
        定义默认参数要牢记一点：默认参数必须指向不变对象！
    可变参数
        在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
        def colc（*num）
    关键字参数
        和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：
    **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，
    注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。

    命名关键字参数
        要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：
        def person(name, age, city, job):
             # 缺少 *，city和job被视为位置参数
            pass
    参数组合
        参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

递归函数
    使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
    针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
    Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

高级特性
    切片
        L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
        L[-1:]，L[-1]取倒数第一个元素
    迭代
        迭代是通过for ... in来完成
    列表生成式
        列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。
        举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：
    生成器（Iterator对象）
        t = (b, a + b) # t是一个tuple
        a = t[0]
        b = t[1]

        定义 generator
            函数定义中包含yield关键字
            generator函数的“调用”实际返回一个generator对象：

    迭代器（Iterator迭代器对象）
        生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
    小结
        凡是可作用于for循环的对象都是Iterable类型；
        凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
        集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
        Python的for循环本质上就是通过不断调用next()函数实现的
        for x in [1, 2, 3, 4, 5]:
          pass
        实际上完全等价于：
        # 首先获得Iterator对象:
        it = iter([1, 2, 3, 4, 5])
        # 循环:
        while True:
            try:
                # 获得下一个值:
                x = next(it)
            except StopIteration:
                # 遇到StopIteration就退出循环
                break

函数式编程
    高阶函数
        map和reduce
        fiter
        sorted
返回函数
    闭包
    一个函数可以返回一个计算结果，也可以返回一个函数。
    返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。

匿名函数
    lambda
装饰器
    functools.wraps
偏函数(当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数)
    int2 = functools.partial(int,base=2)
    print(int2('101101'))

模块
    _private_ 、public


运算符（a=21，b=10）
    /:a/b=2.1
    %：取模 - 返回除法的余数 a%b=1
    //:取整除 - 返回商的整数部分（向下取整)a//b=2,9//2=4,-9//2=-5
    **:幂 - 返回x的y次幂	2**3 = 8
    =:比较int值是否相等
    ==:幂 - 返回x的y次幂
    =	简单的赋值运算符	c = a + b 将 a + b 的运算结果赋值为 c
    +=	加法赋值运算符	c += a 等效于 c = c + a
    -=	减法赋值运算符	c -= a 等效于 c = c - a
    *=	乘法赋值运算符	c *= a 等效于 c = c * a
    /=	除法赋值运算符	c /= a 等效于 c = c / a
    %=	取模赋值运算符	c %= a 等效于 c = c % a
    **=	幂赋值运算符	c **= a 等效于 c = c ** a
    //=	取整除赋值运算符	c //= a 等效于 c = c // a
    &	按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	(a & b) 输出结果 12 ，二进制解释： 0000 1100
    |	按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	(a | b) 输出结果 61 ，二进制解释： 0011 1101
    ^	按位异或运算符：当两对应的二进位相异时，结果为1	(a ^ b) 输出结果 49 ，二进制解释： 0011 0001
    ~	按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1	(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。
    <<	左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。	a << 2 输出结果 240 ，二进制解释： 1111 0000
    >>	右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数	a >> 2 输出结果 15 ，二进制解释： 0000 1111

面向对象
    三大特征
        封装、继承、多态

    __slots__绑定某些属性，只对当前类，不对子类影响

    静态方法和类方法
        @staticmethod
        @classmethod

    继承
        一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，
        子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力

    多态
        子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。
        通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，
        不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。

    抽象类
        @abstractmethod
        抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它，如果一个类中定义了抽象方法那么
        这个类就不能被势例化（不能创建对象）

random.shuffle
__str__()
__repr__()


文件
    finally代码总执行块
    with指定文件对象上下文环境并在离开上下文环境时自动释放文件资源
    readlines
    try
    except
    读取二进制
        rt
        wt
    json
        dump 按照json格式序列化到文件中
        dumps 处理成json格式的字符串
        load 将文件中json数据反序列化
        loads   将字符串内容反序列化成python对象
        序列化
            序列化（serialization）在计算机科学的数据处理中，是指将数据结构或
            对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态
            ，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本
            （拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反
            序列化（deserialization）”。